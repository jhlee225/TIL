# 5장 실행 컨텍스트와 클로저

## 실행 컨텍스트

: 실행 가능한 코드를 형상화 하고 구분하는 추상적인 개념.  
실행 가능한 자바스크립트 코드블록이 실행되는 환경.

전역코드, eval( )로 실행되는 코드, 함수안의 코드를 실행할 경우 실행 컨텍스트가 생성

현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면,  
 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동한다.

### 실행컨텍스트의 생성

### `활성객체 생성`

활성객체 : JS 엔진이 컨텍스트 실행에 필요한 여러가지 정보를 담을 객체.

사용자가 정의한 변수 및 객체를 저장하고 새로 만들어진 컨텍스트로 엔진 내부에서 접근 가능하게 되어있음

### `Arguments 객체 생성`

활성객체의 argument 프로퍼티에 argument 객체를 참조

### `스코프 정보 생성`

현재 컨텍스트의 유효 범위를 나타내는 스코프 정보를 생성

스코프 정보는 현재 실행중인 실행 컨텍스트 안에서 Linked List 와 유사한 형식으로 만들어져

현재 컨텍스트에서 특정 변수에 접근해야 할 경우 이 List 를 활용함

이 List를 통해 현재 컨텍스트의 변수 뿐 아니라 상위 실행 컨텍스트의 변수도 접근 가능

> 이 List에서 찾지 못한 변수는 정의되지 않은 변수로 판단하여 에러를 검출한다.

### `변수 생성`

지역변수의 생성. 변수객체에 변수를 저장한다고 하는데 , 앞서 생성한 활성객체가 변수 객체임

변수 객체 안에서 호출된 함수 인자는 각각의 프로퍼티가 만들어지고 그 값이 할당된다.

(만약 값이 넘겨지지 않았다면 undefined)

메모리에 변수를 생성만 하고 초기화는 각 변수나 함수에 해당하는 표현식이 실행되기 전까지는 이루어지지 않음.

### `this 바인딩`

this 를 바인딩함... 4장참조

### `코드 실행`

변수의 초기화 및 연산 또 다른 함수의 실행 등이 이루어짐.

전역 실행 컨텍스트는 argument 객체가 없으며 전역객체 하나만을 포함하는 스코프체인이 있음.

- 전역 실행 컨텍스트의 내부함수 = 탑 레벨의 함수로 선언
- 전역 실행 컨텍스트의 변수객체 = 전역객체
- 전역 실행 컨텍스트의 this = 전역객체 참조

## 스코프체인

변수와 함수의 존재의 유효범위

각각의 함수는 scope 프로퍼티로 자신이 생성된 실행 컨텍스트의 스코프 체인을 참조

함수가 실행되는 순간 실행 컨텍스트가 만들어지고, 이 실행 컨텍스트는 실행된 함수의 scope 프로퍼티를 기반으로 새로운 스코프체인을 만듬

> 전역 실행 컨텍스트의 스코프 체인 = 자기 자신의 변수객체
>
> 스코프체인 = 현재 실행 컨텍스트의 변수객체 + 상위 컨텍스트의 스코프 체인

## 클로저

내부함수가 실행될 때 내부함수는 외부함수의 스코프체인을 가지게 되어 내부함수가 외부함수의 변수객체를 참조 할 수 있음

클로저 : 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수 = 외부함수의 변수를 참조한 내부함수

자유변수 : 클로저로 참조되는 외부 변수

> 클로저를 사용시 접근하는 변수가 스코프체인의 첫번째 객체가 아닌 그 이후의 객체에 존재하여  
> 메모리에 부담이 많아져 성능 저하의 원인이 되기도 한다.  
> 그렇다고 클로저를 쓰지 않는 것은 자바스크립트의 강력한 기능 하나를 무시하고 사용하는 것과 다름없음.
>
> 결론 : 많이 써봐서 영리하게 사용하자~

- 클로저의 프로퍼티 값이 쓰기 가능하므로 그 값이 여러번 호출로 항상 변할 수 있음에 유의한다.
- 하나의 클로저가 여러 함수객체의 스코프에 들어가 있는 경우도 있다.
- 루프안에서 클로저를 활용할 때는 주의할 것
-
